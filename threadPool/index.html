<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>线程池 - 小黑屋</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u7ebf\u7a0b\u6c60";
    var mkdocs_page_input_path = "threadPool.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> 小黑屋</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">首页</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Android</span>
    <ul class="subnav">
                <li class="">
                    
    <span class="caption-text">编译/脚本</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../annotation/">Annotation注解处理器</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../annotation_debug/">注解处理器调试</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../android_flavor/">Android渠道写入方式</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">框架</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../glide/">Glide</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../lightKV/">lightKV</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../mmkv/">MMKV</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../eventbus/">EventBus</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../okhttp/">OkHttp</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../okhttp_dns/">OkHttp-Dns</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../okhttp_retry/">Okhttp重试机制</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">系统分析</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../strictMode/">StrictMode</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../touchEventDispatch/">触摸事件分发</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">Webview</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../webview_cache/">缓存机制</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../webview_native/">和Native通信</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../webview_bug/">漏洞</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../webview_optmize/">优化</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">代码片段</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../code/bubble_view/">微信气泡</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">适配</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../dev_compat/">系统适配</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">多媒体</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../renderscript/">RenderScript</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">安全</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../android_safe/">建议</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../android_danger/">风险点</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">工具</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../adb_input/">adb模拟屏幕触摸</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../tcpdump/">tcpdump</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">热修复</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../classloader/">ClassLoader</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../instantRun/">Instant Run</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../robust/">Robust</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../hotFix/">热修复方案</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">未分类</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../keepAlive/">应用保活</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">性能优化</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../bitmap/">Bitmap</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">网络</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../sni/">SNI</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">工具</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../ffmpeg/">FFMPEG</a>
                </li>
                <li class="">
                    
    <a class="" href="../dmg/">DMG</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Java</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../mmap/">内存映射</a>
                </li>
                <li class="">
                    
    <a class="" href="../java_poet/">JavaPoet</a>
                </li>
                <li class="">
                    
    <a class="" href="../volatile/">Volatile</a>
                </li>
                <li class="">
                    
    <a class="" href="../java_collections/">Collections</a>
                </li>
                <li class="">
                    
    <a class="" href="../class_access/">access$xxx</a>
                </li>
                <li class="">
                    
    <span class="caption-text">Concurrent</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../volatile/">volatile</a>
                </li>
    </ul>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">线程池</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#_1">线程池</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#_2">常用线程池</a></li>
        
            <li><a class="toctree-l4" href="#_3">源码分析</a></li>
        
            <li><a class="toctree-l4" href="#_7">线程池饱和策略</a></li>
        
            <li><a class="toctree-l4" href="#_12">阻塞队列</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../java_generic/">泛型通配符</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">虚拟机</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../jvm/">内存模型</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../bookmark/">收藏</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">小黑屋</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Java &raquo;</li>
        
      
    
    <li>线程池</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">线程池</h1>
<h2 id="_2">常用线程池</h2>
<p>常用的线程池都是直接或间接通过配置ThreadPoolExecutor来实现不同特性的线程池。</p>
<p>比较最常见的四类具有不同特性的线程池分别为：</p>
<ol>
<li>FixedThreadPool  </li>
</ol>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }
</code></pre>

<p>只有核心线程，并且数量固定的，也不会被回收，所有线程都活动时，因为队列没有限制大小，新任务会等待执行。 <br />
优点:更快的响应外界请求。</p>
<ol>
<li>
<p>SingleThreadPool<br />
只有一个核心线程，相当于FixedThreadPool(1)</p>
</li>
<li>
<p>CachedThreadPool  </p>
</li>
</ol>
<pre><code class="java">public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }
</code></pre>

<p>核心线程数0，只有非核心线程，最大线程数非常大，所有线程都活动时，会为新任务创建新线程，否则会利用空闲线程(60s空闲时间，过了就会被回收，所以线程池中有0个线程的可能)处理任务。 <br />
优点: 任何任务都会被立即执行(任务队列SynchronousQueue相当于一个空集合); 比较适合执行大量的耗时较少的任务。</p>
<ol>
<li>ScheduledThreadPool  </li>
</ol>
<pre><code class="java">public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE,
              10, MILLISECONDS,
              new DelayedWorkQueue());
}
</code></pre>

<p>核心线程数固定，非核心线程(闲着没活干会被立即回收)数没有限制。 <br />
优点: 适合执行定时任务以及有固定周期的重复任务</p>
<h2 id="_3">源码分析</h2>
<h3 id="_4">状态定义</h3>
<pre><code class="java">    //用一个integer记录状态和线程数
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    //高3位作为状态，低29位作为线程计数
    private static final int COUNT_BITS = Integer.SIZE - 3;
    //最大线程数承受容量，低29位全部为1
    private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

    //线程池状态定义
    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

    //获取状态
    private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
    //获取线程数
    private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
    //设置状态和线程数
    private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>

<p>线程池内部定义了线程池的状态和线程数量， ThreadPoolExecutor 使用AtomicInteger类型的<code>ctl</code>来综合表示线程池状态及线程数量，其中线程池状态用高<code>3</code>位表示，线程数量用低<code>29</code>位表示。</p>
<p>线程池状态可通过数字大小进行比较，另外状态是单调递增变化，不保证所有状态都会经历。     </p>
<p>线程池状态包括以下几种：
* RUNNING<br />
    可接收新任务，且可执行队列里的任务
* SHUTDOWN<br />
    调用shutdown()，不接收新任务，但仍执行队列里的任务
* STOP<br />
    调用shutdownNow()，不接收新任务，且不执行队列里的任务，且会中断正在执行的任务
* TIDYING<br />
    所有任务都已结束，线程池数量为0，线程转换到该状态时会调用terminated()方法
* TERMINATED<br />
    terminated()方法执行结束</p>
<h3 id="_5">关键参数</h3>
<ul>
<li>corePoolSize<br />
    线程池核心线程数量</li>
<li>maximumPoolSize<br />
    线程池允许最大线程数量</li>
<li>keepAliveTime<br />
    超出线程池核心数量之外的空闲线程存活时间</li>
<li>workQueue<br />
    任务阻塞队列</li>
</ul>
<h3 id="_6">提交任务</h3>
<pre><code class="java">public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();

        // 提交任务，考虑三个因素：线程池运行状态 当前活跃线程数量 任务队列
        int c = ctl.get();
        //当前活跃线程数量少于核心线程数，直接创建核心线程任务执行
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 执行到这里说明线程池数量超过核心线程数量，或前面创建核心线程已失败
        // 如果线程池在运行，添加到队列
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            // 由于多线程问题，比如线程池可能已关闭，那么这个任务是不应该入队的
            int recheck = ctl.get();
            // 这里在将任务添加到队列后，重新检查 线程池运行状态 以及 当前活跃线程数量
            // 线程池不是Running，尝试从队列移除刚添加的任务，如果返回true，则说明移除成功，返回false则说明任务已不在队列
            if (! isRunning(recheck) &amp;&amp; remove(command))
                //从队列移除，走饱和策略处理
                reject(command);
            else if (workerCountOf(recheck) == 0)
                // 线程池处于Running，可能由于线程执行任务抛出异常，导致线程数量为0，那么此时需要重新创建线程
                addWorker(null, false);
        }
        //队列里添加不了，直接创建非核心线程执行
        else if (!addWorker(command, false))
            reject(command);
    }
</code></pre>

<p><img alt="threadPool" src="../assets/63.svg" /></p>
<p>从图可以看出，线程池执行所提交的任务过程主要有这样几个阶段：</p>
<ol>
<li>先判断核心线程池是否已满(当前运行线程数 &gt;= corePoolSie)。如果不是，则新创建一个线程执行刚提交的任务，否则进入第2步；</li>
<li>判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中等待；否则，则进入第3步；</li>
<li>判断线程池中是否已满(当前运行线程数 == maxCorePoolSie)，如果没有，则创建一个新的线程来执行任务，否则，最后交给饱和策略进行处理。</li>
</ol>
<h2 id="_7">线程池饱和策略</h2>
<ul>
<li>AbortPolicy<br />
为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出。</li>
<li>DiscardPolicy<br />
直接抛弃，任务不执行，空方法</li>
<li>DiscardOldestPolicy<br />
从队列里面抛弃head的一个任务，并再次执行此task。</li>
<li>CallerRunsPolicy <br />
在调用execute的线程里面执行此command，会阻塞入口</li>
<li>用户自定义拒绝策略 <br />
实现RejectedExecutionHandler，并自己定义策略模式</li>
</ul>
<h3 id="_8">创建线程任务</h3>
<pre><code class="java">   private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            //如果是SHUTDOWN之后的状态，则不会接受新任务
            //如果是SHUTDOWN状态，但是队列还有任务没执行，则还需要执行，否则也是返回false
            if (rs &gt;= SHUTDOWN &amp;&amp;
                ! (rs == SHUTDOWN &amp;&amp;
                   firstTask == null &amp;&amp;
                   ! workQueue.isEmpty()))
                return false;

            // 乐观锁，确保线程数量+1
            for (;;) {
                int wc = workerCountOf(c);
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))//线程数+1
                    break retry;//跳出外层for循环
                c = ctl.get();  
                if (runStateOf(c) != rs)
                    //状态不对？继续外层for循环
                    continue retry;
            }
        }

        // 以上部分只是增加了线程数量，但并未创建真正的线程，下面才是真正的创建线程
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //创建worker，创建新线程，但是该线程仍是孤立的线程，没有加入线程池中，没法被线程池调度
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                //考虑到多线程并发问题，刚才增加完线程数量后，线程池状态可能已经发生了变化
                //因此，接下来对代码进行加锁，避免多线程问题，然后重新检查线程状态是否满足条件
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);//加入线程池
                        int s = workers.size();
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                // 如果线程添加到线程池成功，就start该线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {  
            // 如果线程添加到线程池失败，就回滚刚才增加的线程池线程数量
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }

    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);//移出线程池
            decrementWorkerCount();//线程数-1
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }
</code></pre>

<h3 id="_9">线程执行</h3>
<p>当线程（内部 Worker类）被成功添加到线程池后，会开始执行线程，worker类实现了Runnable</p>
<pre><code class="java">    private final class Worker extends AbstractQueuedSynchronizer implements Runnable

    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        //注意newThread传参this，也就是线程会执行当前worker的run方法。
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker. */
    public void run() {
        //线程运行从这里开始
        runWorker(this);
    }

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        //实际的线程任务为task
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //一个worker线程通过while死循环不断获取新的任务来执行
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;&amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();//真正执行线程池任务
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            //处理任务完成
            processWorkerExit(w, completedAbruptly);
        }
    }
</code></pre>

<h3 id="_10">获取队列任务</h3>
<pre><code class="java">    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 以下两种情况直接返回，并且结束该worker线程（返回null）
            // - 线程池处于SHUTDOWN状态且任务队列为空
            // - 线程池处于STOP之后的状态
            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // 线程数量超过最大线程数量，或者超过核心线程数量，或者允许核心线程获取任务超时
            // 这种情况下，获取阻塞队列中的任务，需要指定最大等待时间，即keepAliveTime
            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
                // 由于线程池数量可能动态变化，所以，尝试减少线程数并最终结束该线程
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //从阻塞队列获取任务，注意poll和take都是阻塞式获取，其中poll可以指定最大阻塞时间，而take可以一直阻塞。
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                //等待超时了，进入下一个循环，之后可能将退出线程。
                timedOut = false;
            }
        }
    }
</code></pre>

<h3 id="_11">线程清理</h3>
<pre><code class="java">    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) &gt;= min)
                    return; // replacement not needed
            }
            // 异常关闭线程 或 线程数量不满足最小值时创建线程，以防止线程全部异常结束时，任务队列里的其他任务没法继续执行
            addWorker(null, false);
        }
    }
</code></pre>

<h2 id="_12">阻塞队列</h2>
<p>CachedThreadPool 中使用 SynchronousQueue 作为阻塞队列</p>
<pre><code>take() &amp; put() //这是阻塞的，会阻塞操作线程
poll() &amp; offer() //这是非阻塞的（在不设置超时时间的前提下）
</code></pre>
<p>synchronousQueue是一个<code>没有数据缓冲</code>的阻塞队列（也就是排队数不超过1），生产者线程对其的插入操作put()必须等待消费者的移除操作take()，反过来也一样。</p>
<p>对于使用 synchronousQueue 的线程池，在第一次execute任务的时候offer()返回false，因为线程池中还没有线程，所以没有消费者在等待，所以就会直接创建线程进行执行任务，而不能加入队列。</p>
<p>当一个worker线程执行完成后，使用take或pool获取下一个队列任务时，相当于有一个消费者在等待，这时再次调用execute的任务，就可以加入队列(offer成功)，这样就达到了cachedThreadPool线程复用的目的。</p>
<p>简单的说还是使用synchronousQueue的线程池，队列中最多存只有一个任务，且立马会被取出执行(worker线程复用)，否则都是创建新的worker线程执行新任务。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../java_generic/" class="btn btn-neutral float-right" title="泛型通配符">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../volatile/" class="btn btn-neutral" title="volatile"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../volatile/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../java_generic/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
