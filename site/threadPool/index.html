<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>线程池 - 小黑屋</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.0.4, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">小黑屋</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">首页</a>
<li class="header">Android</li>

<li>
<a href="#">编译/脚本</a>
<ul>

<li>
<a href="../annotation/" class="">Annotation注解处理器</a>
</li>

<li>
<a href="../annotation_debug/" class="">注解处理器调试</a>
</li>

<li>
<a href="../android_flavor/" class="">Android渠道写入方式</a>
</li>
</ul>
</li>

<li>
<a href="#">框架</a>
<ul>

<li>
<a href="../glide/" class="">Glide</a>
</li>

<li>
<a href="../lightKV/" class="">lightKV</a>
</li>

<li>
<a href="../mmkv/" class="">MMKV</a>
</li>

<li>
<a href="../eventbus/" class="">EventBus</a>
</li>

<li>
<a href="../okhttp/" class="">OkHttp</a>
</li>

<li>
<a href="../okhttp_dns/" class="">OkHttp-Dns</a>
</li>

<li>
<a href="../okhttp_retry/" class="">Okhttp重试机制</a>
</li>
</ul>
</li>

<li>
<a href="#">系统分析</a>
<ul>

<li>
<a href="../strictMode/" class="">StrictMode</a>
</li>

<li>
<a href="../touchEventDispatch/" class="">触摸事件分发</a>
</li>
</ul>
</li>

<li>
<a href="#">Webview</a>
<ul>

<li>
<a href="../webview_cache/" class="">缓存机制</a>
</li>

<li>
<a href="../webview_native/" class="">和Native通信</a>
</li>

<li>
<a href="../webview_bug/" class="">漏洞</a>
</li>

<li>
<a href="../webview_optmize/" class="">优化</a>
</li>
</ul>
</li>

<li>
<a href="#">代码片段</a>
<ul>

<li>
<a href="../code/bubble_view/" class="">微信气泡</a>
</li>
</ul>
</li>

<li>
<a href="#">适配</a>
<ul>

<li>
<a href="../dev_compat/" class="">系统适配</a>
</li>
</ul>
</li>

<li>
<a href="#">多媒体</a>
<ul>

<li>
<a href="../renderscript/" class="">RenderScript</a>
</li>
</ul>
</li>

<li>
<a href="#">安全</a>
<ul>

<li>
<a href="../android_safe/" class="">建议</a>
</li>

<li>
<a href="../android_danger/" class="">风险点</a>
</li>
</ul>
</li>

<li>
<a href="#">工具</a>
<ul>

<li>
<a href="../adb_input/" class="">adb模拟屏幕触摸</a>
</li>

<li>
<a href="../tcpdump/" class="">tcpdump</a>
</li>
</ul>
</li>

<li>
<a href="#">热修复</a>
<ul>

<li>
<a href="../classloader/" class="">ClassLoader</a>
</li>

<li>
<a href="../instantRun/" class="">Instant Run</a>
</li>

<li>
<a href="../robust/" class="">Robust</a>
</li>

<li>
<a href="../hotFix/" class="">热修复方案</a>
</li>
</ul>
</li>

<li>
<a href="#">未分类</a>
<ul>

<li>
<a href="../keepAlive/" class="">应用保活</a>
</li>
</ul>
</li>

<li>
<a href="#">性能优化</a>
<ul>

<li>
<a href="../bitmap/" class="">Bitmap</a>
</li>
</ul>
</li>

<li class="header">网络</li>

<li>
<a href="../sni/" class="">SNI</a>
</li>

<li class="header">工具</li>

<li>
<a href="../ffmpeg/" class="">FFMPEG</a>
</li>

<li>
<a href="../dmg/" class="">DMG</a>
</li>

<li class="header">Java</li>

<li>
<a href="../mmap/" class="">内存映射</a>
</li>

<li>
<a href="../java_poet/" class="">JavaPoet</a>
</li>

<li>
<a href="../volatile/" class="">Volatile</a>
</li>

<li>
<a href="../java_collections/" class="">Collections</a>
</li>

<li>
<a href="../class_access/" class="">access$xxx</a>
</li>

<li>
<a href="#">Concurrent</a>
<ul>

<li>
<a href="../volatile/" class="">volatile</a>
</li>
</ul>
</li>

<li>
<a href="./" class="active">线程池</a>
</li>

<li>
<a href="../java_generic/" class="">泛型通配符</a>
</li>

<li class="header">虚拟机</li>

<li>
<a href="../jvm/" class="">内存模型</a>
</li>

<li class="chapter" data-path="bookmark/">
<a href="../bookmark/">收藏</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="_1">线程池</h1>
<h2 id="_2">常用线程池</h2>
<p>常用的线程池都是直接或间接通过配置ThreadPoolExecutor来实现不同特性的线程池。</p>
<p>比较最常见的四类具有不同特性的线程池分别为：</p>
<ol>
<li>FixedThreadPool  </li>
</ol>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }
</code></pre>

<p>只有核心线程，并且数量固定的，也不会被回收，所有线程都活动时，因为队列没有限制大小，新任务会等待执行。 <br />
优点:更快的响应外界请求。</p>
<ol>
<li>
<p>SingleThreadPool<br />
只有一个核心线程，相当于FixedThreadPool(1)</p>
</li>
<li>
<p>CachedThreadPool  </p>
</li>
</ol>
<pre><code class="java">public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }
</code></pre>

<p>核心线程数0，只有非核心线程，最大线程数非常大，所有线程都活动时，会为新任务创建新线程，否则会利用空闲线程(60s空闲时间，过了就会被回收，所以线程池中有0个线程的可能)处理任务。 <br />
优点: 任何任务都会被立即执行(任务队列SynchronousQueue相当于一个空集合); 比较适合执行大量的耗时较少的任务。</p>
<ol>
<li>ScheduledThreadPool  </li>
</ol>
<pre><code class="java">public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE,
              10, MILLISECONDS,
              new DelayedWorkQueue());
}
</code></pre>

<p>核心线程数固定，非核心线程(闲着没活干会被立即回收)数没有限制。 <br />
优点: 适合执行定时任务以及有固定周期的重复任务</p>
<h2 id="_3">源码分析</h2>
<h3 id="_4">状态定义</h3>
<pre><code class="java">    //用一个integer记录状态和线程数
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    //高3位作为状态，低29位作为线程计数
    private static final int COUNT_BITS = Integer.SIZE - 3;
    //最大线程数承受容量，低29位全部为1
    private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

    //线程池状态定义
    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

    //获取状态
    private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
    //获取线程数
    private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
    //设置状态和线程数
    private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>

<p>线程池内部定义了线程池的状态和线程数量， ThreadPoolExecutor 使用AtomicInteger类型的<code>ctl</code>来综合表示线程池状态及线程数量，其中线程池状态用高<code>3</code>位表示，线程数量用低<code>29</code>位表示。</p>
<p>线程池状态可通过数字大小进行比较，另外状态是单调递增变化，不保证所有状态都会经历。     </p>
<p>线程池状态包括以下几种：
* RUNNING<br />
    可接收新任务，且可执行队列里的任务
* SHUTDOWN<br />
    调用shutdown()，不接收新任务，但仍执行队列里的任务
* STOP<br />
    调用shutdownNow()，不接收新任务，且不执行队列里的任务，且会中断正在执行的任务
* TIDYING<br />
    所有任务都已结束，线程池数量为0，线程转换到该状态时会调用terminated()方法
* TERMINATED<br />
    terminated()方法执行结束</p>
<h3 id="_5">关键参数</h3>
<ul>
<li>corePoolSize<br />
    线程池核心线程数量</li>
<li>maximumPoolSize<br />
    线程池允许最大线程数量</li>
<li>keepAliveTime<br />
    超出线程池核心数量之外的空闲线程存活时间</li>
<li>workQueue<br />
    任务阻塞队列</li>
</ul>
<h3 id="_6">提交任务</h3>
<pre><code class="java">public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();

        // 提交任务，考虑三个因素：线程池运行状态 当前活跃线程数量 任务队列
        int c = ctl.get();
        //当前活跃线程数量少于核心线程数，直接创建核心线程任务执行
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 执行到这里说明线程池数量超过核心线程数量，或前面创建核心线程已失败
        // 如果线程池在运行，添加到队列
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            // 由于多线程问题，比如线程池可能已关闭，那么这个任务是不应该入队的
            int recheck = ctl.get();
            // 这里在将任务添加到队列后，重新检查 线程池运行状态 以及 当前活跃线程数量
            // 线程池不是Running，尝试从队列移除刚添加的任务，如果返回true，则说明移除成功，返回false则说明任务已不在队列
            if (! isRunning(recheck) &amp;&amp; remove(command))
                //从队列移除，走饱和策略处理
                reject(command);
            else if (workerCountOf(recheck) == 0)
                // 线程池处于Running，可能由于线程执行任务抛出异常，导致线程数量为0，那么此时需要重新创建线程
                addWorker(null, false);
        }
        //队列里添加不了，直接创建非核心线程执行
        else if (!addWorker(command, false))
            reject(command);
    }
</code></pre>

<p><img alt="threadPool" src="../assets/63.svg" /></p>
<p>从图可以看出，线程池执行所提交的任务过程主要有这样几个阶段：</p>
<ol>
<li>先判断核心线程池是否已满(当前运行线程数 &gt;= corePoolSie)。如果不是，则新创建一个线程执行刚提交的任务，否则进入第2步；</li>
<li>判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中等待；否则，则进入第3步；</li>
<li>判断线程池中是否已满(当前运行线程数 == maxCorePoolSie)，如果没有，则创建一个新的线程来执行任务，否则，最后交给饱和策略进行处理。</li>
</ol>
<h2 id="_7">线程池饱和策略</h2>
<ul>
<li>AbortPolicy<br />
为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出。</li>
<li>DiscardPolicy<br />
直接抛弃，任务不执行，空方法</li>
<li>DiscardOldestPolicy<br />
从队列里面抛弃head的一个任务，并再次执行此task。</li>
<li>CallerRunsPolicy <br />
在调用execute的线程里面执行此command，会阻塞入口</li>
<li>用户自定义拒绝策略 <br />
实现RejectedExecutionHandler，并自己定义策略模式</li>
</ul>
<h3 id="_8">创建线程任务</h3>
<pre><code class="java">   private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            //如果是SHUTDOWN之后的状态，则不会接受新任务
            //如果是SHUTDOWN状态，但是队列还有任务没执行，则还需要执行，否则也是返回false
            if (rs &gt;= SHUTDOWN &amp;&amp;
                ! (rs == SHUTDOWN &amp;&amp;
                   firstTask == null &amp;&amp;
                   ! workQueue.isEmpty()))
                return false;

            // 乐观锁，确保线程数量+1
            for (;;) {
                int wc = workerCountOf(c);
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))//线程数+1
                    break retry;//跳出外层for循环
                c = ctl.get();  
                if (runStateOf(c) != rs)
                    //状态不对？继续外层for循环
                    continue retry;
            }
        }

        // 以上部分只是增加了线程数量，但并未创建真正的线程，下面才是真正的创建线程
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //创建worker，创建新线程，但是该线程仍是孤立的线程，没有加入线程池中，没法被线程池调度
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                //考虑到多线程并发问题，刚才增加完线程数量后，线程池状态可能已经发生了变化
                //因此，接下来对代码进行加锁，避免多线程问题，然后重新检查线程状态是否满足条件
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);//加入线程池
                        int s = workers.size();
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                // 如果线程添加到线程池成功，就start该线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {  
            // 如果线程添加到线程池失败，就回滚刚才增加的线程池线程数量
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }

    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);//移出线程池
            decrementWorkerCount();//线程数-1
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }
</code></pre>

<h3 id="_9">线程执行</h3>
<p>当线程（内部 Worker类）被成功添加到线程池后，会开始执行线程，worker类实现了Runnable</p>
<pre><code class="java">    private final class Worker extends AbstractQueuedSynchronizer implements Runnable

    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        //注意newThread传参this，也就是线程会执行当前worker的run方法。
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker. */
    public void run() {
        //线程运行从这里开始
        runWorker(this);
    }

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        //实际的线程任务为task
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //一个worker线程通过while死循环不断获取新的任务来执行
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;&amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();//真正执行线程池任务
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            //处理任务完成
            processWorkerExit(w, completedAbruptly);
        }
    }
</code></pre>

<h3 id="_10">获取队列任务</h3>
<pre><code class="java">    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 以下两种情况直接返回，并且结束该worker线程（返回null）
            // - 线程池处于SHUTDOWN状态且任务队列为空
            // - 线程池处于STOP之后的状态
            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // 线程数量超过最大线程数量，或者超过核心线程数量，或者允许核心线程获取任务超时
            // 这种情况下，获取阻塞队列中的任务，需要指定最大等待时间，即keepAliveTime
            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
                // 由于线程池数量可能动态变化，所以，尝试减少线程数并最终结束该线程
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //从阻塞队列获取任务，注意poll和take都是阻塞式获取，其中poll可以指定最大阻塞时间，而take可以一直阻塞。
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                //等待超时了，进入下一个循环，之后可能将退出线程。
                timedOut = false;
            }
        }
    }
</code></pre>

<h3 id="_11">线程清理</h3>
<pre><code class="java">    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) &gt;= min)
                    return; // replacement not needed
            }
            // 异常关闭线程 或 线程数量不满足最小值时创建线程，以防止线程全部异常结束时，任务队列里的其他任务没法继续执行
            addWorker(null, false);
        }
    }
</code></pre>

<h2 id="_12">阻塞队列</h2>
<p>CachedThreadPool 中使用 SynchronousQueue 作为阻塞队列</p>
<pre><code>take() &amp; put() //这是阻塞的，会阻塞操作线程
poll() &amp; offer() //这是非阻塞的（在不设置超时时间的前提下）
</code></pre>
<p>synchronousQueue是一个<code>没有数据缓冲</code>的阻塞队列（也就是排队数不超过1），生产者线程对其的插入操作put()必须等待消费者的移除操作take()，反过来也一样。</p>
<p>对于使用 synchronousQueue 的线程池，在第一次execute任务的时候offer()返回false，因为线程池中还没有线程，所以没有消费者在等待，所以就会直接创建线程进行执行任务，而不能加入队列。</p>
<p>当一个worker线程执行完成后，使用take或pool获取下一个队列任务时，相当于有一个消费者在等待，这时再次调用execute的任务，就可以加入队列(offer成功)，这样就达到了cachedThreadPool线程复用的目的。</p>
<p>简单的说还是使用synchronousQueue的线程池，队列中最多存只有一个任务，且立马会被取出执行(worker线程复用)，否则都是创建新的worker线程执行新任务。</p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>