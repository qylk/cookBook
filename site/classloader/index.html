<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>ClassLoader - 小黑屋</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "ClassLoader";
    var mkdocs_page_input_path = "classloader.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> 小黑屋</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">首页</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Android</span>
    <ul class="subnav">
                <li class="">
                    
    <span class="caption-text">编译/脚本</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../annotation/">Annotation注解处理器</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../annotation_debug/">注解处理器调试</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../android_flavor/">Android渠道写入方式</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">框架</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../glide/">Glide</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../lightKV/">lightKV</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../mmkv/">MMKV</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../eventbus/">EventBus</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../okhttp/">OkHttp</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../okhttp_dns/">OkHttp-Dns</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../okhttp_retry/">Okhttp重试机制</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">系统分析</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../strictMode/">StrictMode</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../touchEventDispatch/">触摸事件分发</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">Webview</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../webview_cache/">缓存机制</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../webview_native/">和Native通信</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../webview_bug/">漏洞</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../webview_optmize/">优化</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">代码片段</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../code/bubble_view/">微信气泡</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">适配</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../dev_compat/">系统适配</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">多媒体</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../renderscript/">RenderScript</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">安全</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../android_safe/">建议</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../android_danger/">风险点</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">工具</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../adb_input/">adb模拟屏幕触摸</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../tcpdump/">tcpdump</a>
                </li>
    </ul>
                </li>
                <li class=" current">
                    
    <span class="caption-text">热修复</span>
    <ul class="subnav">
                <li class="toctree-l3 current">
                    
    <a class="current" href="./">ClassLoader</a>
    <ul class="subnav">
            
    <li class="toctree-l4"><a href="#_1">简介</a></li>
    

    <li class="toctree-l4"><a href="#1">源码分析1</a></li>
    

    <li class="toctree-l4"><a href="#_2">双亲委托</a></li>
    

    <li class="toctree-l4"><a href="#2">源码分析2</a></li>
    

    </ul>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../instantRun/">Instant Run</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../robust/">Robust</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../hotFix/">热修复方案</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">未分类</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../keepAlive/">应用保活</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">性能优化</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../bitmap/">Bitmap</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">网络</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../sni/">SNI</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">工具</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../ffmpeg/">FFMPEG</a>
                </li>
                <li class="">
                    
    <a class="" href="../dmg/">DMG</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Java</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../mmap/">内存映射</a>
                </li>
                <li class="">
                    
    <a class="" href="../java_poet/">JavaPoet</a>
                </li>
                <li class="">
                    
    <a class="" href="../volatile/">Volatile</a>
                </li>
                <li class="">
                    
    <a class="" href="../java_collections/">Collections</a>
                </li>
                <li class="">
                    
    <a class="" href="../class_access/">access$xxx</a>
                </li>
                <li class="">
                    
    <span class="caption-text">Concurrent</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../volatile/">volatile</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../threadPool/">线程池</a>
                </li>
                <li class="">
                    
    <a class="" href="../java_generic/">泛型通配符</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">虚拟机</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../jvm/">内存模型</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../bookmark/">收藏</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">小黑屋</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>热修复 &raquo;</li>
        
      
        
          <li>Android &raquo;</li>
        
      
    
    <li>ClassLoader</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">简介</h1>
<p>ClassLoader顾名思义是Java虚拟机用来加载Class的。</p>
<p>Java应用中主要的ClassLoader是：
* BootStrapClassLoader：虚拟机层面ClassLoader，使用C++编写，用来加载java核心jar包中的Class，如String.class。
* ExtClassLoader：标准扩展类加载器
* AppClassLoader：加载当前应用程序中的所有类</p>
<hr />
<p>由于Android虚拟机不同于普通Java虚拟机，Java虚拟机执行的是jar包里的Class文件，而android上Class被编译进android特有的DEX文件中，因此在ClassLoader这块也有些不同。</p>
<p><img alt="classloader" src="../assets/24.jpg" /></p>
<p>Android 中 ClassLoader 一共有上图几种，比较常见的是<code>BootClassLoader</code>和<code>PathClassLoader</code>。</p>
<ul>
<li>BootClassLoader，是用来加载android framework中的Class</li>
<li>PathClassLoader，是通过指定Path来加载Class的，通常用来加载我们应用程序中的Class</li>
</ul>
<pre><code class="java">public MainActivity extends Activity {
    public void onCreate(){
        ClassLoader bootClassLoader = Activity.class.getClassLoader();
        ClassLoader pathClassLoader = MainActivity.class.getClassLoader();
    }
}
</code></pre>

<p>另外一个<code>DexClassLoader</code>也比较常用，一般用来加载自定义的jar/dex，常用在插件化和热修复等场景中。</p>
<h1 id="1">源码分析1</h1>
<p>先看ClassLoader的构造方法，需要传入一个参数为parent的ClassLoader。</p>
<pre><code class="java">    /**
     * Creates a new class loader using the specified parent class loader for
     * delegation.
     *
     * @param  parent The parent class loader
     */
    protected ClassLoader(ClassLoader parent) {
        this(checkCreateClassLoader(), parent);
    }
</code></pre>

<p>通常加载一个class，需要给定class名称，并调用ClassLoader的loadClass方法。</p>
<pre><code class="java">classLoader.loadClass(&quot;com.xxx.yyy&quot;)
</code></pre>

<p>看下loadClass方法实现</p>
<pre><code class="java">//ClassLoader.java
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
        //先检查是否之前已经加载过，如果已经加载过，则返回
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    //让parent去加载class
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {

            }
            if (c == null) {
                //parent没有找到，使用findClass来自己找
                c = findClass(name);
            }
        }
        return c;
}
</code></pre>

<p>可以看到，加载class的流程是：
1. <code>findLoadedClass</code>，先尝试找找是否这个class已经之前加载过，如果找到，直接返回已加载的class。
2. 调用相同的接口<code>loadClass</code>，让<code>parent</code>去加载class，这叫委托。
3. 如果parent没有找到，最后通过this.<code>findClass</code>自己来找class，如果还没有找到，findClass将抛出ClassNotFoundException异常，如果找到，返回class。</p>
<h1 id="_2">双亲委托</h1>
<p>从上面的流程可以看到，当一个Classloader去加载class时，会先委托自己的parentClassLoader去加载，parent没找到，才轮到自己来加载。在标准的Java中，这叫<code>双亲委托机制</code>。</p>
<p><img alt="classloader" src="../assets/25.jpeg" /></p>
<p>为什么采用<code>双亲委托</code>呢？<br />
主要是考虑安全性，我们知道java核心库中有一个类叫java.lang.String，如果我们的应用程序也写了这样一个类java.lang.String，名字一模一样。由于classLoader加载class只根据类名查找，因此如果不采用<code>双亲委托</code>机制，那么虚拟机可能会优先加载我们自己写的java.lang.String类，可想而知这是非常危险的。</p>
<p><code>双亲委托机制</code>是JVM规范要求，android虚拟机也遵循该要求。比如，当我们使用PathClassLoader去加载应用程序中的class的时候，PathClassLoader会委托parent，也就是BootCLassLoader先加载。</p>
<h1 id="2">源码分析2</h1>
<p>继续来看findClass的实现</p>
<pre><code class="java">//ClassLoader
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
</code></pre>

<p>可以看到直接抛出异常，说明具体的实现不在ClassLoader.java中，我们先看BootClassLoader中的实现</p>
<pre><code class="java">//BootClassLoader
@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    return Class.classForName(name, false, null);
}
</code></pre>

<p>Class#classForName是一个native方法，交给android虚拟机在C++层面加载。  </p>
<p>再看下PathClassLoader中的实现</p>
<pre><code class="java">/*
* 由于PathClassLoader继承自BaseDexClassLoader，
* 我们在BaseDexClassLoader中找到了findClass的实现
*/
@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    Class clazz = pathList.findClass(name);//通过pathList查找
    if (clazz == null) {
       throw new ClassNotFoundException(name);
    }
    return clazz;
}
</code></pre>

<p>pathList是什么？看下类型定义</p>
<pre><code class="java">private final DexPathList pathList;
</code></pre>

<p>继续找到它的findClass的实现</p>
<pre><code class="java">//DexPathList

/** list of dex/resource (class path) elements */
private final Element[] dexElements;

public Class findClass(String name) {
        //遍历dexElements数组
        for (Element element : dexElements) {
            //从element中取出dexFile(这代表一个dex文件)
            DexFile dex = element.dexFile;
            if (dex != null) {
                //从dexFile中加载class
                Class clazz = dex.loadClassBinaryName(name, definingContext);
                if (clazz != null) {
                    return clazz;
                }
            }
        }
        return null;
}
</code></pre>

<pre><code class="java">// DexFile构造函数
public DexFile(File file) throws IOException {
    this(file.getPath());
}
</code></pre>

<p>我们知道android中应用代码的class会被编译进dex文件中。<br />
而通过上面代码可知，PathClassLoader(其实是BaseDexClassLoader)维护一个<code>DexPathList</code>成员对象，该对象中又维护了一个<code>dexElements</code>数组，每个数组元素又包装了一个<code>DexFile</code>对象，最终从<code>DexFile</code>加载我们需要的class，这个过程是通过<code>loadClassBinaryName</code>来实现的，由于是native方法，且涉及到Dex文件格式的知识，不再研究，但是作用已经很明显了，就是从编译的dex文件中取出class。</p>
<p>前面提到还有一个DexClassLoader，他和PathClassLoader都传承自BaseDexClassLoader，因此他们都可以用来加载dex文件中的class，那么有什么不同呢? </p>
<pre><code class="java">// DexClassLoader
public class DexClassLoader extends BaseDexClassLoader {
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(dexPath, new File(optimizedDirectory), libraryPath, parent);
    }
}

// PathClassLoader
public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super(dexPath, null, null, parent);
    }

    public PathClassLoader(String dexPath, String libraryPath,
            ClassLoader parent) {
        super(dexPath, null, libraryPath, parent);
    }
}
</code></pre>

<p>上面就是两个ClassLoader的全部代码，可见非常简单，无非就是构造函数不一样。<br />
仔细看可知，唯一的不同是DexClassLoader需要传入一个optimizedDirectory的参数，而PathClassLoader不需要，在对父类BaseClassLoader初始化时，PathClassLoader传入了null。</p>
<p>这个<code>optimizedDirectory</code>是什么意思呢？其实看名字知道这是一个目录，我们知道dex文件首次加载时会进行dexopt操作，将dex文件优化为odex文件，<code>optimizedDirectory</code>即为优化后的odex文件的存放目录。</p>
<p>通过进一步的源码分析可知：如果<code>optimizedDirectory</code>参数为空，则使用系统默认的odex缓存路径，一般是：<code>/data/dalvik-cache/</code>。</p>
<p>所以DexClassLoader与PathClassLoader的本质区别就是DexClassLoader可以指定odex的缓存路径，而PathClassLoader则采用系统默认的缓存路径。
实际上这个 <code>optimizedDirectory</code> 在 Android 8.0 以后也被舍弃了，只能使用系统默认的位置了。</p>
<pre><code class="java">public class DexClassLoader extends BaseDexClassLoader {
    /**
     * @param optimizedDirectory this parameter is deprecated * and has no effect since API level 26.
     */
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String librarySearchPath, ClassLoader parent) {
        super(dexPath, null, librarySearchPath, parent);
    }
}
</code></pre>

<p>所以说 PathClassLoader 和 DexClassLoader 其实并没有多大区别，但是一般而言，使用PathDexClassLoader用来加载已安装的apk的dex，使用DexClassLoader加载未被虚拟机加载的外部dex。
假如非要使用PathDexClassLoader来加载外部的dex其实也是可以成功的。</p>
<hr />
<p>其他classLoader
* InMemoryDexClassLoader</p>
<pre><code>是API26新增的类加载器，可用于加载内存中的dex。
</code></pre>
<ul>
<li>
<p>DelegateLastClassLoader</p>
<p>是API27新增的类加载器，是一个先查找再委托的类加载器实现<br />
<code>java
protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    Class&lt;?&gt; cl = findLoadedClass(name);
    if (cl != null) {
        return cl;
    }
    try {
        return Object.class.getClassLoader().loadClass(name);
    } catch (ClassNotFoundException ignored) {
    }
    ClassNotFoundException fromSuper = null;
    try {
        return findClass(name);
    } catch (ClassNotFoundException ex) {
        fromSuper = ex;
    }
    try {
        return getParent().loadClass(name);
    } catch (ClassNotFoundException cnfe) {
        throw fromSuper;
    }
}</code>  </p>
</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../instantRun/" class="btn btn-neutral float-right" title="Instant Run">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../tcpdump/" class="btn btn-neutral" title="tcpdump"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../tcpdump/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../instantRun/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
