<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Glide load - 小黑屋</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.0.4, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">小黑屋</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">首页</a>
<li class="header">Android</li>

<li>
<a href="#">编译/脚本</a>
<ul>

<li>
<a href="../annotation/" class="">Annotation注解处理器</a>
</li>

<li>
<a href="../annotation_debug/" class="">注解处理器调试</a>
</li>

<li>
<a href="../android_flavor/" class="">Android渠道写入方式</a>
</li>
</ul>
</li>

<li>
<a href="#">框架</a>
<ul>

<li>
<a href="../glide/" class="">Glide</a>
</li>

<li>
<a href="../lightKV/" class="">lightKV</a>
</li>

<li>
<a href="../mmkv/" class="">MMKV</a>
</li>

<li>
<a href="../eventbus/" class="">EventBus</a>
</li>
</ul>
</li>

<li>
<a href="#">系统分析</a>
<ul>

<li>
<a href="../strictMode/" class="">StrictMode</a>
</li>

<li>
<a href="../touchEventDispatch/" class="">触摸事件分发</a>
</li>
</ul>
</li>

<li>
<a href="#">Webview</a>
<ul>

<li>
<a href="../webview_cache/" class="">缓存机制</a>
</li>

<li>
<a href="../webview_native/" class="">和Native通信</a>
</li>

<li>
<a href="../webview_bug/" class="">漏洞</a>
</li>

<li>
<a href="../webview_optmize/" class="">优化</a>
</li>
</ul>
</li>

<li>
<a href="#">代码片段</a>
<ul>

<li>
<a href="../code/bubble_view/" class="">微信气泡</a>
</li>
</ul>
</li>

<li>
<a href="#">适配</a>
<ul>

<li>
<a href="../dev_compat/" class="">系统适配</a>
</li>
</ul>
</li>

<li>
<a href="#">安全</a>
<ul>

<li>
<a href="../android_safe/" class="">建议</a>
</li>
</ul>
</li>

<li>
<a href="#">工具</a>
<ul>

<li>
<a href="../adb_input/" class="">adb模拟屏幕触摸</a>
</li>

<li>
<a href="../tcpdump/" class="">tcpdump</a>
</li>
</ul>
</li>

<li>
<a href="#">热修复</a>
<ul>

<li>
<a href="../classloader/" class="">ClassLoader</a>
</li>

<li>
<a href="../instantRun/" class="">Instant Run</a>
</li>

<li>
<a href="../robust/" class="">Robust</a>
</li>

<li>
<a href="../hotFix/" class="">热修复方案</a>
</li>
</ul>
</li>

<li>
<a href="#">未分类</a>
<ul>

<li>
<a href="../keepAlive/" class="">应用保活</a>
</li>
</ul>
</li>

<li>
<a href="#">性能优化</a>
<ul>

<li>
<a href="../bitmap/" class="">Bitmap</a>
</li>
</ul>
</li>

<li class="header">网络</li>

<li>
<a href="../sni/" class="">SNI</a>
</li>

<li class="header">工具</li>

<li>
<a href="../ffmpeg/" class="">FFMPEG</a>
</li>

<li>
<a href="../dmg/" class="">DMG</a>
</li>

<li class="header">Java</li>

<li>
<a href="../mmap/" class="">内存映射</a>
</li>

<li>
<a href="../java_poet/" class="">JavaPoet</a>
</li>

<li>
<a href="../volatile/" class="">Volatile</a>
</li>

<li>
<a href="../java_collections/" class="">Collections</a>
</li>

<li>
<a href="../class_access/" class="">access$xxx</a>
</li>

<li>
<a href="#">Concurrent</a>
<ul>

<li>
<a href="../volatile/" class="">volatile</a>
</li>
</ul>
</li>

<li>
<a href="../threadPool/" class="">线程池</a>
</li>

<li class="header">虚拟机</li>

<li>
<a href="../jvm/" class="">内存模型</a>
</li>

<li>
<a href="../gc/" class="">GC</a>
</li>

<li class="chapter" data-path="bookmark/">
<a href="../bookmark/">收藏</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h2 id="glide-load-into">Glide源码分析 - load-into方法</h2>
<p>继续看load方法，记下了我们的url(就是mode)，设置isModelSet为true，就结束了。</p>
<pre><code class="java"> public GenericRequestBuilder load(ModelType model) {
        this.model = model;
        isModelSet = true;
        return this;
    }
</code></pre>

<p>直到load方法结束，我们的图片请求都还没有开始，都是在给RequestBuilder组装参数。<br />
看来重点在into方法中，into方法在GenericRequestBuilder中实现的。</p>
<pre><code class="java">public Target&lt;TranscodeType&gt; into(ImageView view) {
        Util.assertMainThread();//!!into方法只能在主线程调!!
        return into(glide.buildImageViewTarget(view, transcodeClass));
    }
</code></pre>

<p>先将ImageView和transcodeClass包装成一个ImageViewTarget，从上面可知，transcodeClass为PicassoDrawable类型。</p>
<pre><code class="java">public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView view, Class&lt;Z&gt; clazz) {
        if (PicassoDrawable.class.isAssignableFrom(clazz)) {
            return (Target&lt;Z&gt;) new GlideDrawableImageViewTarget(view);
        } else if (Bitmap.class.equals(clazz)) {
            return (Target&lt;Z&gt;) new BitmapImageViewTarget(view);
        } else if (Drawable.class.isAssignableFrom(clazz)) {
            return (Target&lt;Z&gt;) new DrawableImageViewTarget(view);
        } else {
            throw new IllegalArgumentException(&quot;Unhandled class: &quot; + clazz
                    + &quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;);
        }
    }
</code></pre>

<p>这里对不同的transcodeClass，返回不同的Target，在我们的分析中，transcodeClass为PicassoDrawable类型，将返回GlideDrawableImageViewTarget对象。
我们看下Target接口的定义，显然Target首先是个LifecycleListener，可感知界面生命周期，是不是有点像LiveData？
为什么要感知生命周期，因为gif图片在界面不可见时，应该停止动画，这里就是靠LifecycleListener实现的。
其次Target还定义了图片资源的各种回调方法、获取viewSize和记录对应的request图片请求。</p>
<pre><code class="java">public interface Target&lt;R&gt; extends LifecycleListener {
    //开始加载
    void onLoadStarted(Drawable placeholder);
    //加载失败
    void onLoadFailed(Exception e, Drawable errorDrawable);
    //加载成功
    void onResourceReady(R resource, GlideAnimation&lt;? super R&gt; glideAnimation);
    //加载清除
    void onLoadCleared(Drawable placeholder);
    //获取viewSize
    void getSize(SizeReadyCallback cb);

    //记录对应的request
    void setRequest(Request request);
    Request getRequest();
}
</code></pre>

<p>Target接口的各种实现类，无非就是实现Target接口方法，有关ImageView的各种Target就是把ImageView对象包装成一个target。
有了target，继续看into方法</p>
<pre><code class="java">public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) {
        Util.assertMainThread();

        //看有没有旧的request，有就先取消
        Request previous = target.getRequest();
        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }

        //RequestBuilder终于build成request了
        Request request = buildRequest(target);
        target.setRequest(request);//request记录到target中
        lifecycle.addListener(target);//target需要监听生命周期
        requestTracker.runRequest(request);//执行request
        return target;
    }
</code></pre>

<p>先不看buildRequest方法，接着看runRequest方法，在RequestTracker类中</p>
<pre><code class="java">/**
 * A class for tracking, canceling, and restarting in progress, completed, and failed requests.
 */
public class RequestTracker 
</code></pre>

<p>RequestTracker顾名思义，用于跟踪Request，可以取消，重启request的辅助类，属于RequestManager职责中的一部分。</p>
<pre><code class="java">    public void runRequest(Request request) {
        requests.add(request);//加入列表
        if (!isPaused) {//RequestManager未暂停？
            request.begin();//开始
        } else {
            pendingRequests.add(request);//加入等待列表
        }
    }
</code></pre>

<p>好像加入了2个列表requests和pendingRequests，有什么区别？
看下定义：</p>
<pre><code class="java"> private final Set&lt;Request&gt; requests = Collections.newSetFromMap(new WeakHashMap&lt;Request, Boolean&gt;());
 private final List&lt;Request&gt; pendingRequests = new ArrayList&lt;Request&gt;();
</code></pre>

<p>requests是弱引用列表，pendingRequests是强引用列表，所有的request都被加入了requests中，因为是弱引用，不存在内存泄漏风险。而
因为Glide暂停而未执行的request被加入pendingRequests中，纯粹是为了防止这些request对象被回收，因为Glide在恢复(resume)时还需要执行这些request。
我们上面看到在buildRequest后，request被记录到了target中，瞅一眼ViewTarget中的setRequest方法</p>
<pre><code class="java">    /**
     * Stores the request using {@link View#setTag(Object)}.
     */
    @Override
    public void setRequest(Request request) {
        setTag(request);
    }
</code></pre>

<p>可以看到request通过View的setTag被View强引用，只要View不回收，request就不会被回收。但是Target并不都是ViewTarget类型，所以Glide担心开发者在Target中未强引用request对象，导致request还被未执行就被回收了，才设计了上面所说的pendingRequests强引用列表。</p>
<p>接着回到runRequest方法，看request.begin，begin方法定义在GenericRequest类中</p>
<pre><code class="java">    @Override
    public void begin() {
        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this);
        }
        if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
    }
</code></pre>

<p>首先检查两个size是否是确定值，主要指是否是正数，或者等于特定的SIZE_ORIGINAL(指原图大小)，两值默认均为-1。</p>
<pre><code class="java">private int overrideHeight = -1;
private int overrideWidth = -1;

private static boolean isValidDimension(int dimen) {
        return dimen &gt; 0 || dimen == Target.SIZE_ORIGINAL;
}
</code></pre>

<p>如果size是确定值，则走入onSizeReady方法，否则调用target的getSize方法计算size，传入回调SizeReadyCallback参数为this，也就是说size计算完以后也会回调
onSizeReady方法，最后就是调用target的onLoadStarted通知请求要开始了。
在ImageViewTarget类中找到了onLoadStarted实现，就是渲染placeholder图片。</p>
<pre><code class="java">    @Override
    public void onLoadStarted(Drawable placeholder) {
        view.setImageDrawable(placeholder);
    }
</code></pre>

<p>后面我们会知道request正式开始的地方是在onSizeReady方法中，但是我们先来看之前的异步getSize方法，定位在ViewTarget类中。</p>
<pre><code class="java">        public void getSize(SizeReadyCallback cb) {
            int currentWidth = getViewWidthOrParam();
            int currentHeight = getViewHeightOrParam();
            if (isSizeValid(currentWidth) &amp;&amp; isSizeValid(currentHeight)) {
                cb.onSizeReady(currentWidth, currentHeight);
            } else {
                // We want to notify callbacks in the order they were added and we only expect one or two callbacks to
                // be added a time, so a List is a reasonable choice.
                if (!cbs.contains(cb)) {
                    cbs.add(cb);
                }
                if (layoutListener == null) {
                    final ViewTreeObserver observer = view.getViewTreeObserver();
                    layoutListener = new SizeDeterminerLayoutListener(this);
                    observer.addOnPreDrawListener(layoutListener);
                }
            }
        }
</code></pre>

<p>可知获取size，首先是从View的LayoutParams中获取，如果还是不确定，就使用ViewTreeObserver监听View的PreDraw回调，在PreDraw回调中继续尝试获取size。
可想而知，如果size如果始终无法确定，那么onSizeReady方法将不会被调用，request也将不会被执行。所以说使用Glide一般需要明确view的大小，或者通过override接口指定图片大小，否则图片可能显示不出来。</p>
<p>最后来看关键的onSizeReady方法</p>
<pre><code class="java">    @Override
    public void onSizeReady(int width, int height) {
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;//request状态置为运行中

        width = Math.round(sizeMultiplier * width);//确定最终尺寸
        height = Math.round(sizeMultiplier * height);

        ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();
        //获取Fetcher
        final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);
        //获取Transcoder
        ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();

        loadedFromMemoryCache = true;
        //开始load
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
    }
</code></pre>

<p>最后落脚到engine.load方法上，传入参数很多，我们的图片请求就从这儿要开始了。</p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>