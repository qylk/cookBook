<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Glide first - 小黑屋</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.0.4, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">小黑屋</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">首页</a>
<li class="header">Android</li>

<li>
<a href="#">编译/脚本</a>
<ul>

<li>
<a href="../annotation/" class="">Annotation注解处理器</a>
</li>

<li>
<a href="../annotation_debug/" class="">注解处理器调试</a>
</li>

<li>
<a href="../android_flavor/" class="">Android渠道写入方式</a>
</li>
</ul>
</li>

<li>
<a href="#">框架</a>
<ul>

<li>
<a href="../glide/" class="">Glide</a>
</li>

<li>
<a href="../lightKV/" class="">lightKV</a>
</li>

<li>
<a href="../mmkv/" class="">MMKV</a>
</li>

<li>
<a href="../eventbus/" class="">EventBus</a>
</li>
</ul>
</li>

<li>
<a href="#">系统分析</a>
<ul>

<li>
<a href="../strictMode/" class="">StrictMode</a>
</li>

<li>
<a href="../touchEventDispatch/" class="">触摸事件分发</a>
</li>
</ul>
</li>

<li>
<a href="#">Webview</a>
<ul>

<li>
<a href="../webview_cache/" class="">缓存机制</a>
</li>

<li>
<a href="../webview_native/" class="">和Native通信</a>
</li>

<li>
<a href="../webview_bug/" class="">漏洞</a>
</li>

<li>
<a href="../webview_optmize/" class="">优化</a>
</li>
</ul>
</li>

<li>
<a href="#">代码片段</a>
<ul>

<li>
<a href="../code/bubble_view/" class="">微信气泡</a>
</li>
</ul>
</li>

<li>
<a href="#">适配</a>
<ul>

<li>
<a href="../dev_compat/" class="">系统适配</a>
</li>
</ul>
</li>

<li>
<a href="#">安全</a>
<ul>

<li>
<a href="../android_safe/" class="">建议</a>
</li>
</ul>
</li>

<li>
<a href="#">工具</a>
<ul>

<li>
<a href="../adb_input/" class="">adb模拟屏幕触摸</a>
</li>

<li>
<a href="../tcpdump/" class="">tcpdump</a>
</li>
</ul>
</li>

<li>
<a href="#">热修复</a>
<ul>

<li>
<a href="../classloader/" class="">ClassLoader</a>
</li>

<li>
<a href="../instantRun/" class="">Instant Run</a>
</li>

<li>
<a href="../robust/" class="">Robust</a>
</li>

<li>
<a href="../hotFix/" class="">热修复方案</a>
</li>
</ul>
</li>

<li>
<a href="#">未分类</a>
<ul>

<li>
<a href="../keepAlive/" class="">应用保活</a>
</li>
</ul>
</li>

<li>
<a href="#">性能优化</a>
<ul>

<li>
<a href="../bitmap/" class="">Bitmap</a>
</li>
</ul>
</li>

<li class="header">网络</li>

<li>
<a href="../sni/" class="">SNI</a>
</li>

<li class="header">工具</li>

<li>
<a href="../ffmpeg/" class="">FFMPEG</a>
</li>

<li>
<a href="../dmg/" class="">DMG</a>
</li>

<li class="header">Java</li>

<li>
<a href="../mmap/" class="">内存映射</a>
</li>

<li>
<a href="../java_poet/" class="">JavaPoet</a>
</li>

<li>
<a href="../volatile/" class="">Volatile</a>
</li>

<li>
<a href="../java_collections/" class="">Collections</a>
</li>

<li>
<a href="../class_access/" class="">access$xxx</a>
</li>

<li>
<a href="#">Concurrent</a>
<ul>

<li>
<a href="../volatile/" class="">volatile</a>
</li>
</ul>
</li>

<li>
<a href="../threadPool/" class="">线程池</a>
</li>

<li class="header">虚拟机</li>

<li>
<a href="../jvm/" class="">内存模型</a>
</li>

<li>
<a href="../gc/" class="">GC</a>
</li>

<li class="chapter" data-path="bookmark/">
<a href="../bookmark/">收藏</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h2 id="glide-with">Glide源码分析 - with方法</h2>
<p>with方法有多个重载，但代码基本相同
<img alt="glide" src="../assets/44.png" /></p>
<pre><code class="java">public static RequestManager with(Activity activity) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(activity);
    }
</code></pre>

<p><code>RequestManagerRetriever</code>是个单例</p>
<pre><code class="java">    public RequestManager get(Context context) {
        if (context == null) {
            throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);
        } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {
            if (context instanceof FragmentActivity) {
                return get((FragmentActivity) context);
            } else if (context instanceof Activity) {
                return get((Activity) context);
            } else if (context instanceof ContextWrapper) {
                return get(((ContextWrapper) context).getBaseContext());
            }
        }

        return getApplicationManager(context);
    }
</code></pre>

<p>get方法也有多个重载</p>
<pre><code class="java">    public RequestManager get(Activity activity) {
        if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
            return get(activity.getApplicationContext());
        } else {
            assertNotDestroyed(activity);
            android.app.FragmentManager fm = activity.getFragmentManager();
            return fragmentGet(activity, fm);
        }
    }
</code></pre>

<p>从重载方法可以看出，如果传入的<code>context</code>为<code>application</code> 或者 当前线程不在主线程(<code>isOnBackgroundThread</code>)，则通过调用<code>getApplicationManager</code>返回，否则都调用<code>fragmentGet</code>方法返回<code>RequestManager</code>。  </p>
<p>我们后面会知道Glide通过fragment感知界面生命周期，所以我们开发过程中，应该确认context不为applicationContext，且在主线程调用，否则将失去Glide对界面生命周期感知这一功能。</p>
<p>感知生命周期有什么好处呢？
Glide对于图片请求会在onStop的时候自动暂停，然后在onStart的时候重新启动，gif的动画也会在onStop的时候停止，以免在后台消耗电量。</p>
<pre><code class="java">    RequestManager fragmentGet(Context context, android.app.FragmentManager fm) {
        RequestManagerFragment current = getRequestManagerFragment(fm);
        RequestManager requestManager = current.getRequestManager();
        if (requestManager == null) {
            //传入Lifecycle接口，让requestManager可监听fragment的生命周期
            requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
            //requestManager保存在fragment中
            current.setRequestManager(requestManager);
        }
        return requestManager;
    }

    RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {
        //先找之前有没有创建
        RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
        if (current == null) {
            current = pendingRequestManagerFragments.get(fm);
            if (current == null) {
                current = new RequestManagerFragment();
                //因为添加fragment是异步的，所以先加入pending，避免重复new RequestManagerFragment
                pendingRequestManagerFragments.put(fm, current);
                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
                handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();//稍后从penging中移除
            }
        }
        return current;
    }
</code></pre>

<p>可知，不管加载多少图片，一个activity，总是对应一个有RequestManagerFragment对象，且RequestManagerFragment包含一个RequestManager对象，所以他们的生存期是一样的。
Glide的with方法最终返回了一个RequestManager对象，顾名思义，RequestManager应该是管理Request的，是一个管理者。<br />
load方法显然在RequestManager中，load也是有多个重载方法，可以传入不同类型的参数，以常用的String类型的url为例：</p>
<pre><code class="java">    public DrawableTypeRequest&lt;String&gt; load(String string) {
        return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);
    }

    public DrawableTypeRequest&lt;String&gt; fromString() {
        return loadGeneric(String.class);
    }

    private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) {
        ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
        ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =
                Glide.buildFileDescriptorModelLoader(modelClass, context);
        return optionsApplier.apply(
                new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
                        glide, requestTracker, lifecycle, optionsApplier));
    }
</code></pre>

<ul>
<li>modelClass是指输入参数类型，比如我们传入的是String类型的url字符串，则modelClass为String.class</li>
<li>resourceClass是指数据资源类型，我们从网络上下载图片，图片数据以流的形式存在，则resourceClass为InputStream.class</li>
</ul>
<p>我们知道Glide在其构造方法中默认注册了一大堆ModelLoader工厂类，比如：</p>
<pre><code class="java">register(String.class, InputStream.class, new StreamStringLoader.Factory());
</code></pre>

<p>loadGeneric方法最终创建一个DrawableTypeRequest对象返回，并在其中注入了modelClass，modeLoader，lifecycle等等参数。</p>
<pre><code class="java">public class DrawableTypeRequest&lt;ModelType&gt; extends DrawableRequestBuilder&lt;ModelType&gt;
public class DrawableRequestBuilder&lt;ModelType&gt;
        extends GenericRequestBuilder&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, PicassoDrawable&gt;
public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt;         
</code></pre>

<p>DrawableTypeRequest 继承自 DrawableRequestBuilder，DrawableRequestBuilder 又继承自 GenericRequestBuilder。</p>
<p>GenericRequestBuilder中的Generic是指拥有泛型，可见GenericRequestBuilder需要指定4个泛型：</p>
<ul>
<li>ModelType: 图片资源地址的类型，如String.class</li>
<li>DataType: 图片原始数据类型，如InputStream.class</li>
<li>ResourceType: 图片类型，如Bitmap.class, GifDrawable.class</li>
<li>TranscodeType: 图片转换后额类型，如Drawable.class</li>
</ul>
<p>DrawableRequestBuilder 除了ModelType，确定了后三个泛型：</p>
<ul>
<li>DataType -&gt; ImageVideoWrapper，包装了InputStream和ParcelFileDescriptor两种类型</li>
<li>DataType -&gt; GifBitmapWrapper，包装了GifDrawable和Bitmap两种类型</li>
<li>TranscodeType -&gt; PicassoDrawable，引自于Picasso项目的Drawable类</li>
</ul>
<p>DrawableTypeRequest 在 DrawableRequestBuilder 区别不大，只是添加了一些额外几个方法而已。
显然DrawableTypeRequest也是个RequestBuilder，既然是Builder，作用就是记录request的各种参数以及类型。</p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>