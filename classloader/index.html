<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>ClassLoader - 小黑屋</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.0.4, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">小黑屋</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">首页</a>
<li class="header">Android</li>

<li>
<a href="#">编译/脚本</a>
<ul>

<li>
<a href="../annotation/" class="">Annotation注解处理器</a>
</li>

<li>
<a href="../annotation_debug/" class="">注解处理器调试</a>
</li>

<li>
<a href="../android_flavor/" class="">Android渠道写入方式</a>
</li>
</ul>
</li>

<li>
<a href="#">框架</a>
<ul>

<li>
<a href="../glide/" class="">Glide</a>
</li>

<li>
<a href="../lightKV/" class="">lightKV</a>
</li>

<li>
<a href="../mmkv/" class="">MMKV</a>
</li>

<li>
<a href="../eventbus/" class="">EventBus</a>
</li>

<li>
<a href="../okhttp/" class="">OkHttp</a>
</li>

<li>
<a href="../okhttp_dns/" class="">OkHttp-Dns</a>
</li>

<li>
<a href="../okhttp_retry/" class="">Okhttp重试机制</a>
</li>
</ul>
</li>

<li>
<a href="#">系统分析</a>
<ul>

<li>
<a href="../strictMode/" class="">StrictMode</a>
</li>

<li>
<a href="../touchEventDispatch/" class="">触摸事件分发</a>
</li>
</ul>
</li>

<li>
<a href="#">Webview</a>
<ul>

<li>
<a href="../webview_cache/" class="">缓存机制</a>
</li>

<li>
<a href="../webview_native/" class="">和Native通信</a>
</li>

<li>
<a href="../webview_bug/" class="">漏洞</a>
</li>

<li>
<a href="../webview_optmize/" class="">优化</a>
</li>
</ul>
</li>

<li>
<a href="#">代码片段</a>
<ul>

<li>
<a href="../code/bubble_view/" class="">微信气泡</a>
</li>
</ul>
</li>

<li>
<a href="#">适配</a>
<ul>

<li>
<a href="../dev_compat/" class="">系统适配</a>
</li>
</ul>
</li>

<li>
<a href="#">多媒体</a>
<ul>

<li>
<a href="../renderscript/" class="">RenderScript</a>
</li>
</ul>
</li>

<li>
<a href="#">安全</a>
<ul>

<li>
<a href="../android_safe/" class="">建议</a>
</li>

<li>
<a href="../android_danger/" class="">风险点</a>
</li>
</ul>
</li>

<li>
<a href="#">工具</a>
<ul>

<li>
<a href="../adb_input/" class="">adb模拟屏幕触摸</a>
</li>

<li>
<a href="../tcpdump/" class="">tcpdump</a>
</li>
</ul>
</li>

<li>
<a href="#">热修复</a>
<ul>

<li>
<a href="./" class="active">ClassLoader</a>
</li>

<li>
<a href="../instantRun/" class="">Instant Run</a>
</li>

<li>
<a href="../robust/" class="">Robust</a>
</li>

<li>
<a href="../hotFix/" class="">热修复方案</a>
</li>
</ul>
</li>

<li>
<a href="#">未分类</a>
<ul>

<li>
<a href="../keepAlive/" class="">应用保活</a>
</li>
</ul>
</li>

<li>
<a href="#">性能优化</a>
<ul>

<li>
<a href="../bitmap/" class="">Bitmap</a>
</li>
</ul>
</li>

<li class="header">网络</li>

<li>
<a href="../sni/" class="">SNI</a>
</li>

<li class="header">工具</li>

<li>
<a href="../ffmpeg/" class="">FFMPEG</a>
</li>

<li>
<a href="../dmg/" class="">DMG</a>
</li>

<li class="header">Java</li>

<li>
<a href="../mmap/" class="">内存映射</a>
</li>

<li>
<a href="../java_poet/" class="">JavaPoet</a>
</li>

<li>
<a href="../volatile/" class="">Volatile</a>
</li>

<li>
<a href="../java_collections/" class="">Collections</a>
</li>

<li>
<a href="../class_access/" class="">access$xxx</a>
</li>

<li>
<a href="#">Concurrent</a>
<ul>

<li>
<a href="../volatile/" class="">volatile</a>
</li>
</ul>
</li>

<li>
<a href="../threadPool/" class="">线程池</a>
</li>

<li>
<a href="../java_generic/" class="">泛型通配符</a>
</li>

<li class="header">虚拟机</li>

<li>
<a href="../jvm/" class="">内存模型</a>
</li>

<li class="chapter" data-path="bookmark/">
<a href="../bookmark/">收藏</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="_1">简介</h1>
<p>ClassLoader顾名思义是Java虚拟机用来加载Class的。</p>
<p>Java应用中主要的ClassLoader是：
* BootStrapClassLoader：虚拟机层面ClassLoader，使用C++编写，用来加载java核心jar包中的Class，如String.class。
* ExtClassLoader：标准扩展类加载器
* AppClassLoader：加载当前应用程序中的所有类</p>
<hr />
<p>由于Android虚拟机不同于普通Java虚拟机，Java虚拟机执行的是jar包里的Class文件，而android上Class被编译进android特有的DEX文件中，因此在ClassLoader这块也有些不同。</p>
<p><img alt="classloader" src="../assets/24.jpg" /></p>
<p>Android 中 ClassLoader 一共有上图几种，比较常见的是<code>BootClassLoader</code>和<code>PathClassLoader</code>。</p>
<ul>
<li>BootClassLoader，是用来加载android framework中的Class</li>
<li>PathClassLoader，是通过指定Path来加载Class的，通常用来加载我们应用程序中的Class</li>
</ul>
<pre><code class="java">public MainActivity extends Activity {
    public void onCreate(){
        ClassLoader bootClassLoader = Activity.class.getClassLoader();
        ClassLoader pathClassLoader = MainActivity.class.getClassLoader();
    }
}
</code></pre>

<p>另外一个<code>DexClassLoader</code>也比较常用，一般用来加载自定义的jar/dex，常用在插件化和热修复等场景中。</p>
<h1 id="1">源码分析1</h1>
<p>先看ClassLoader的构造方法，需要传入一个参数为parent的ClassLoader。</p>
<pre><code class="java">    /**
     * Creates a new class loader using the specified parent class loader for
     * delegation.
     *
     * @param  parent The parent class loader
     */
    protected ClassLoader(ClassLoader parent) {
        this(checkCreateClassLoader(), parent);
    }
</code></pre>

<p>通常加载一个class，需要给定class名称，并调用ClassLoader的loadClass方法。</p>
<pre><code class="java">classLoader.loadClass(&quot;com.xxx.yyy&quot;)
</code></pre>

<p>看下loadClass方法实现</p>
<pre><code class="java">//ClassLoader.java
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
        //先检查是否之前已经加载过，如果已经加载过，则返回
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    //让parent去加载class
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {

            }
            if (c == null) {
                //parent没有找到，使用findClass来自己找
                c = findClass(name);
            }
        }
        return c;
}
</code></pre>

<p>可以看到，加载class的流程是：
1. <code>findLoadedClass</code>，先尝试找找是否这个class已经之前加载过，如果找到，直接返回已加载的class。
2. 调用相同的接口<code>loadClass</code>，让<code>parent</code>去加载class，这叫委托。
3. 如果parent没有找到，最后通过this.<code>findClass</code>自己来找class，如果还没有找到，findClass将抛出ClassNotFoundException异常，如果找到，返回class。</p>
<h1 id="_2">双亲委托</h1>
<p>从上面的流程可以看到，当一个Classloader去加载class时，会先委托自己的parentClassLoader去加载，parent没找到，才轮到自己来加载。在标准的Java中，这叫<code>双亲委托机制</code>。</p>
<p><img alt="classloader" src="../assets/25.jpeg" /></p>
<p>为什么采用<code>双亲委托</code>呢？<br />
主要是考虑安全性，我们知道java核心库中有一个类叫java.lang.String，如果我们的应用程序也写了这样一个类java.lang.String，名字一模一样。由于classLoader加载class只根据类名查找，因此如果不采用<code>双亲委托</code>机制，那么虚拟机可能会优先加载我们自己写的java.lang.String类，可想而知这是非常危险的。</p>
<p><code>双亲委托机制</code>是JVM规范要求，android虚拟机也遵循该要求。比如，当我们使用PathClassLoader去加载应用程序中的class的时候，PathClassLoader会委托parent，也就是BootCLassLoader先加载。</p>
<h1 id="2">源码分析2</h1>
<p>继续来看findClass的实现</p>
<pre><code class="java">//ClassLoader
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
</code></pre>

<p>可以看到直接抛出异常，说明具体的实现不在ClassLoader.java中，我们先看BootClassLoader中的实现</p>
<pre><code class="java">//BootClassLoader
@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    return Class.classForName(name, false, null);
}
</code></pre>

<p>Class#classForName是一个native方法，交给android虚拟机在C++层面加载。  </p>
<p>再看下PathClassLoader中的实现</p>
<pre><code class="java">/*
* 由于PathClassLoader继承自BaseDexClassLoader，
* 我们在BaseDexClassLoader中找到了findClass的实现
*/
@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    Class clazz = pathList.findClass(name);//通过pathList查找
    if (clazz == null) {
       throw new ClassNotFoundException(name);
    }
    return clazz;
}
</code></pre>

<p>pathList是什么？看下类型定义</p>
<pre><code class="java">private final DexPathList pathList;
</code></pre>

<p>继续找到它的findClass的实现</p>
<pre><code class="java">//DexPathList

/** list of dex/resource (class path) elements */
private final Element[] dexElements;

public Class findClass(String name) {
        //遍历dexElements数组
        for (Element element : dexElements) {
            //从element中取出dexFile(这代表一个dex文件)
            DexFile dex = element.dexFile;
            if (dex != null) {
                //从dexFile中加载class
                Class clazz = dex.loadClassBinaryName(name, definingContext);
                if (clazz != null) {
                    return clazz;
                }
            }
        }
        return null;
}
</code></pre>

<pre><code class="java">// DexFile构造函数
public DexFile(File file) throws IOException {
    this(file.getPath());
}
</code></pre>

<p>我们知道android中应用代码的class会被编译进dex文件中。<br />
而通过上面代码可知，PathClassLoader(其实是BaseDexClassLoader)维护一个<code>DexPathList</code>成员对象，该对象中又维护了一个<code>dexElements</code>数组，每个数组元素又包装了一个<code>DexFile</code>对象，最终从<code>DexFile</code>加载我们需要的class，这个过程是通过<code>loadClassBinaryName</code>来实现的，由于是native方法，且涉及到Dex文件格式的知识，不再研究，但是作用已经很明显了，就是从编译的dex文件中取出class。</p>
<p>前面提到还有一个DexClassLoader，他和PathClassLoader都传承自BaseDexClassLoader，因此他们都可以用来加载dex文件中的class，那么有什么不同呢? </p>
<pre><code class="java">// DexClassLoader
public class DexClassLoader extends BaseDexClassLoader {
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(dexPath, new File(optimizedDirectory), libraryPath, parent);
    }
}

// PathClassLoader
public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super(dexPath, null, null, parent);
    }

    public PathClassLoader(String dexPath, String libraryPath,
            ClassLoader parent) {
        super(dexPath, null, libraryPath, parent);
    }
}
</code></pre>

<p>上面就是两个ClassLoader的全部代码，可见非常简单，无非就是构造函数不一样。<br />
仔细看可知，唯一的不同是DexClassLoader需要传入一个optimizedDirectory的参数，而PathClassLoader不需要，在对父类BaseClassLoader初始化时，PathClassLoader传入了null。</p>
<p>这个<code>optimizedDirectory</code>是什么意思呢？其实看名字知道这是一个目录，我们知道dex文件首次加载时会进行dexopt操作，将dex文件优化为odex文件，<code>optimizedDirectory</code>即为优化后的odex文件的存放目录。</p>
<p>通过进一步的源码分析可知：如果<code>optimizedDirectory</code>参数为空，则使用系统默认的odex缓存路径，一般是：<code>/data/dalvik-cache/</code>。</p>
<p>所以DexClassLoader与PathClassLoader的本质区别就是DexClassLoader可以指定odex的缓存路径，而PathClassLoader则采用系统默认的缓存路径。
实际上这个 <code>optimizedDirectory</code> 在 Android 8.0 以后也被舍弃了，只能使用系统默认的位置了。</p>
<pre><code class="java">public class DexClassLoader extends BaseDexClassLoader {
    /**
     * @param optimizedDirectory this parameter is deprecated * and has no effect since API level 26.
     */
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String librarySearchPath, ClassLoader parent) {
        super(dexPath, null, librarySearchPath, parent);
    }
}
</code></pre>

<p>所以说 PathClassLoader 和 DexClassLoader 其实并没有多大区别，但是一般而言，使用PathDexClassLoader用来加载已安装的apk的dex，使用DexClassLoader加载未被虚拟机加载的外部dex。
假如非要使用PathDexClassLoader来加载外部的dex其实也是可以成功的。</p>
<hr />
<p>其他classLoader
* InMemoryDexClassLoader</p>
<pre><code>是API26新增的类加载器，可用于加载内存中的dex。
</code></pre>
<ul>
<li>
<p>DelegateLastClassLoader</p>
<p>是API27新增的类加载器，是一个先查找再委托的类加载器实现<br />
<code>java
protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    Class&lt;?&gt; cl = findLoadedClass(name);
    if (cl != null) {
        return cl;
    }
    try {
        return Object.class.getClassLoader().loadClass(name);
    } catch (ClassNotFoundException ignored) {
    }
    ClassNotFoundException fromSuper = null;
    try {
        return findClass(name);
    } catch (ClassNotFoundException ex) {
        fromSuper = ex;
    }
    try {
        return getParent().loadClass(name);
    } catch (ClassNotFoundException cnfe) {
        throw fromSuper;
    }
}</code>  </p>
</li>
</ul>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>